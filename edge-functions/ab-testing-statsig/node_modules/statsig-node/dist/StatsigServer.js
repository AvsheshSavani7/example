"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
var DynamicConfig_1 = __importDefault(require("./DynamicConfig"));
var ErrorBoundary_1 = __importDefault(require("./ErrorBoundary"));
var Errors_1 = require("./Errors");
var Evaluator_1 = __importDefault(require("./Evaluator"));
var Layer_1 = __importDefault(require("./Layer"));
var LogEvent_1 = __importDefault(require("./LogEvent"));
var LogEventProcessor_1 = __importDefault(require("./LogEventProcessor"));
var StatsigOptions_1 = require("./StatsigOptions");
var core_1 = require("./utils/core");
var StatsigFetcher_1 = __importDefault(require("./utils/StatsigFetcher"));
var MAX_VALUE_SIZE = 64;
var MAX_OBJ_SIZE = 2048;
var MAX_USER_SIZE = 2048;
var hasLoggedNoUserIdWarning = false;
var ExposureLogging;
(function (ExposureLogging) {
    ExposureLogging["Disabled"] = "exposures_disabled";
    ExposureLogging["Enabled"] = "exposures_enabled";
})(ExposureLogging || (ExposureLogging = {}));
var ExposureCause;
(function (ExposureCause) {
    ExposureCause["Automatic"] = "automatic_exposure";
    ExposureCause["Manual"] = "manual_exposure";
})(ExposureCause || (ExposureCause = {}));
/**
 * The global statsig class for interacting with gates, configs, experiments configured in the statsig developer console.  Also used for event logging to view in the statsig console, or for analyzing experiment impacts using pulse.
 */
var StatsigServer = /** @class */ (function () {
    function StatsigServer(secretKey, options) {
        if (options === void 0) { options = {}; }
        this._pendingInitPromise = null;
        this._ready = false;
        this._secretKey = secretKey;
        this._options = (0, StatsigOptions_1.OptionsWithDefaults)(options);
        this._pendingInitPromise = null;
        this._ready = false;
        this._fetcher = new StatsigFetcher_1["default"](this._secretKey, this._options);
        this._evaluator = new Evaluator_1["default"](this._fetcher, this._options);
        this._logger = new LogEventProcessor_1["default"](this._fetcher, this._options);
        this._errorBoundary = new ErrorBoundary_1["default"](secretKey);
    }
    /**
     * Initializes the statsig server SDK. This must be called before checking gates/configs or logging events.
     * @throws Error if a Server Secret Key is not provided
     */
    StatsigServer.prototype.initializeAsync = function () {
        var _this = this;
        return this._errorBoundary.capture(function () {
            if (_this._pendingInitPromise != null) {
                return _this._pendingInitPromise;
            }
            if (_this._ready === true) {
                return Promise.resolve();
            }
            if (typeof _this._secretKey !== 'string' ||
                _this._secretKey.length === 0 ||
                !_this._secretKey.startsWith('secret-')) {
                return Promise.reject(new Errors_1.StatsigInvalidArgumentError('Invalid key provided.  You must use a Server Secret Key from the Statsig console with the node-js-server-sdk'));
            }
            var initPromise = _this._evaluator.init()["finally"](function () {
                _this._ready = true;
                _this._pendingInitPromise = null;
            });
            if (_this._options.initTimeoutMs != null &&
                _this._options.initTimeoutMs > 0) {
                _this._pendingInitPromise = Promise.race([
                    initPromise,
                    new Promise(function (resolve) {
                        setTimeout(function () {
                            _this._ready = true;
                            _this._pendingInitPromise = null;
                            resolve();
                        }, _this._options.initTimeoutMs);
                    }),
                ]);
            }
            else {
                _this._pendingInitPromise = initPromise;
            }
            return _this._pendingInitPromise;
        }, function () {
            _this._ready = true;
            _this._pendingInitPromise = null;
            return Promise.resolve();
        });
    };
    /**
     * Check the value of a gate configured in the statsig console
     * @throws Error if initialize() was not called first
     * @throws Error if the gateName is not provided or not a non-empty string
     */
    StatsigServer.prototype.checkGate = function (user, gateName) {
        var _this = this;
        return this._errorBoundary.capture(function () { return __awaiter(_this, void 0, void 0, function () {
            var gate;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.checkGateImpl(user, gateName, ExposureLogging.Enabled)];
                    case 1:
                        gate = _a.sent();
                        return [2 /*return*/, (gate === null || gate === void 0 ? void 0 : gate.value) === true];
                }
            });
        }); }, function () { return Promise.resolve(false); });
    };
    StatsigServer.prototype.checkGateWithExposureLoggingDisabled = function (user, gateName) {
        var _this = this;
        return this._errorBoundary.capture(function () { return __awaiter(_this, void 0, void 0, function () {
            var gate;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.checkGateImpl(user, gateName, ExposureLogging.Disabled)];
                    case 1:
                        gate = _a.sent();
                        return [2 /*return*/, (gate === null || gate === void 0 ? void 0 : gate.value) === true];
                }
            });
        }); }, function () { return Promise.resolve(false); });
    };
    StatsigServer.prototype.logGateExposure = function (user, gateName) {
        var evaluation = this._evaluator.checkGate(user, gateName);
        this.logGateExposureImpl(user, gateName, evaluation, ExposureCause.Manual);
    };
    /**
     * Checks the value of a config for a given user
     * @throws Error if initialize() was not called first
     * @throws Error if the configName is not provided or not a non-empty string
     */
    StatsigServer.prototype.getConfig = function (user, configName) {
        var _this = this;
        return this._errorBoundary.capture(function () {
            return _this.getConfigImpl(user, configName, ExposureLogging.Enabled);
        }, function () { return Promise.resolve(new DynamicConfig_1["default"](configName)); });
    };
    StatsigServer.prototype.getConfigWithExposureLoggingDisabled = function (user, configName) {
        var _this = this;
        return this._errorBoundary.capture(function () {
            return _this.getConfigImpl(user, configName, ExposureLogging.Disabled);
        }, function () { return Promise.resolve(new DynamicConfig_1["default"](configName)); });
    };
    StatsigServer.prototype.logConfigExposure = function (user, configName) {
        var evaluation = this._evaluator.getConfig(user, configName);
        this.logConfigExposureImpl(user, configName, evaluation, ExposureCause.Manual);
    };
    /**
     * Checks the value of a config for a given user
     * @throws Error if initialize() was not called first
     * @throws Error if the experimentName is not provided or not a non-empty string
     */
    StatsigServer.prototype.getExperiment = function (user, experimentName) {
        var _this = this;
        return this._errorBoundary.capture(function () {
            return _this.getConfigImpl(user, experimentName, ExposureLogging.Enabled);
        }, function () { return Promise.resolve(new DynamicConfig_1["default"](experimentName)); });
    };
    StatsigServer.prototype.getExperimentWithExposureLoggingDisabled = function (user, experimentName) {
        var _this = this;
        return this._errorBoundary.capture(function () {
            return _this.getConfigImpl(user, experimentName, ExposureLogging.Disabled);
        }, function () { return Promise.resolve(new DynamicConfig_1["default"](experimentName)); });
    };
    StatsigServer.prototype.logExperimentExposure = function (user, experimentName) {
        var evaluation = this._evaluator.getConfig(user, experimentName);
        this.logConfigExposureImpl(user, experimentName, evaluation, ExposureCause.Manual);
    };
    /**
     * Checks the value of a config for a given user
     * @throws Error if initialize() was not called first
     * @throws Error if the layerName is not provided or not a non-empty string
     */
    StatsigServer.prototype.getLayer = function (user, layerName) {
        var _this = this;
        return this._errorBoundary.capture(function () {
            return _this.getLayerImpl(user, layerName, ExposureLogging.Enabled);
        }, function () { return Promise.resolve(new Layer_1["default"](layerName)); });
    };
    StatsigServer.prototype.getLayerWithExposureLoggingDisabled = function (user, layerName) {
        var _this = this;
        return this._errorBoundary.capture(function () {
            return _this.getLayerImpl(user, layerName, ExposureLogging.Disabled);
        }, function () { return Promise.resolve(new Layer_1["default"](layerName)); });
    };
    StatsigServer.prototype.logLayerParameterExposure = function (user, layerName, parameterName) {
        var evaluation = this._evaluator.getLayer(user, layerName);
        this.logLayerParameterExposureImpl(user, layerName, parameterName, evaluation, ExposureCause.Manual);
    };
    /**
     * Log an event for data analysis and alerting or to measure the impact of an experiment
     * @throws Error if initialize() was not called first
     */
    StatsigServer.prototype.logEvent = function (user, eventName, value, metadata) {
        var _this = this;
        if (value === void 0) { value = null; }
        if (metadata === void 0) { metadata = null; }
        return this._errorBoundary.swallow(function () {
            _this.logEventObject({
                eventName: eventName,
                user: user,
                value: value,
                metadata: metadata
            });
        });
    };
    StatsigServer.prototype.logEventObject = function (eventObject) {
        var _this = this;
        return this._errorBoundary.swallow(function () {
            var _a, _b, _c, _d;
            var eventName = eventObject.eventName;
            var user = (_a = eventObject.user) !== null && _a !== void 0 ? _a : null;
            var value = (_b = eventObject.value) !== null && _b !== void 0 ? _b : null;
            var metadata = (_c = eventObject.metadata) !== null && _c !== void 0 ? _c : null;
            var time = (_d = eventObject.time) !== null && _d !== void 0 ? _d : null;
            if (!(_this._ready === true && _this._logger != null)) {
                throw new Errors_1.StatsigUninitializedError();
            }
            if (typeof eventName !== 'string' || eventName.length === 0) {
                console.error('statsigSDK::logEvent> Must provide a valid string for the eventName.');
                return;
            }
            if (!(0, core_1.isUserIdentifiable)(user) && !hasLoggedNoUserIdWarning) {
                hasLoggedNoUserIdWarning = true;
                console.warn('statsigSDK::logEvent> No valid userID was provided. Event will be logged but not associated with an identifiable user. This message is only logged once.');
            }
            user = normalizeUser(user, _this._options);
            if (shouldTrimParam(eventName, MAX_VALUE_SIZE)) {
                console.warn('statsigSDK::logEvent> eventName is too long, trimming to ' +
                    MAX_VALUE_SIZE +
                    '.');
                eventName = eventName.substring(0, MAX_VALUE_SIZE);
            }
            if (typeof value === 'string' && shouldTrimParam(value, MAX_VALUE_SIZE)) {
                console.warn('statsigSDK::logEvent> value is too long, trimming to ' +
                    MAX_VALUE_SIZE +
                    '.');
                value = value.substring(0, MAX_VALUE_SIZE);
            }
            if (shouldTrimParam(metadata, MAX_OBJ_SIZE)) {
                console.warn('statsigSDK::logEvent> metadata is too big. Dropping the metadata.');
                metadata = { statsig_error: 'Metadata length too large' };
            }
            var event = new LogEvent_1["default"](eventName);
            event.setUser(user);
            event.setValue(value);
            event.setMetadata(metadata);
            if (typeof time === 'number') {
                event.setTime(time);
            }
            _this._logger.log(event);
        });
    };
    /**
     * Informs the statsig SDK that the server is closing or shutting down
     * so the SDK can clean up internal state
     */
    StatsigServer.prototype.shutdown = function () {
        var _this = this;
        if (this._logger == null) {
            return;
        }
        this._errorBoundary.swallow(function () {
            _this._ready = false;
            _this._logger.shutdown();
            _this._fetcher.shutdown();
            _this._evaluator.shutdown();
        });
    };
    StatsigServer.prototype.flush = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, this._errorBoundary.capture(function () {
                        if (_this._logger == null) {
                            return Promise.resolve();
                        }
                        return _this._logger.flush();
                    }, function () { return Promise.resolve(); })];
            });
        });
    };
    StatsigServer.prototype.getClientInitializeResponse = function (user) {
        var _this = this;
        return this._errorBoundary.capture(function () {
            if (_this._ready !== true) {
                throw new Errors_1.StatsigUninitializedError();
            }
            var normalizedUser = user;
            if (user.statsigEnvironment == null) {
                normalizedUser = normalizeUser(user, _this._options);
            }
            return _this._evaluator.getClientInitializeResponse(normalizedUser);
        }, function () { return null; });
    };
    StatsigServer.prototype.overrideGate = function (gateName, value, userID) {
        var _this = this;
        if (userID === void 0) { userID = ''; }
        this._errorBoundary.swallow(function () {
            if (typeof value !== 'boolean') {
                console.warn('statsigSDK> Attempted to override a gate with a non boolean value');
                return;
            }
            _this._evaluator.overrideGate(gateName, value, userID);
        });
    };
    StatsigServer.prototype.overrideConfig = function (configName, value, userID) {
        var _this = this;
        if (userID === void 0) { userID = ''; }
        this._errorBoundary.swallow(function () {
            if (typeof value !== 'object') {
                console.warn('statsigSDK> Attempted to override a config with a non object value');
                return;
            }
            _this._evaluator.overrideConfig(configName, value, userID);
        });
    };
    StatsigServer.prototype.overrideLayer = function (layerName, value, userID) {
        var _this = this;
        if (userID === void 0) { userID = ''; }
        this._errorBoundary.swallow(function () {
            if (typeof value !== 'object') {
                console.warn('statsigSDK> Attempted to override a layer with a non object value');
                return;
            }
            _this._evaluator.overrideLayer(layerName, value, userID);
        });
    };
    //
    // PRIVATE
    //
    StatsigServer.prototype.logGateExposureImpl = function (user, gateName, evaluation, exposureCause) {
        this._logger.logGateExposure(user, gateName, evaluation, exposureCause === ExposureCause.Manual);
    };
    StatsigServer.prototype.checkGateImpl = function (inputUser, gateName, exposureLogging) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, rejection, user, evaluation, res;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this._validateInputs(inputUser, gateName), rejection = _a.rejection, user = _a.normalizedUser;
                        if (rejection) {
                            return [2 /*return*/, rejection];
                        }
                        evaluation = this._evaluator.checkGate(user, gateName);
                        if (!evaluation.fetch_from_server) return [3 /*break*/, 3];
                        return [4 /*yield*/, this._fetcher.dispatch(this._options.api + '/check_gate', Object.assign({
                                user: user,
                                gateName: gateName,
                                statsigMetadata: (0, core_1.getStatsigMetadata)({
                                    exposureLoggingDisabled: exposureLogging === ExposureLogging.Disabled
                                })
                            }), 5000)];
                    case 1:
                        res = _b.sent();
                        return [4 /*yield*/, res.json()];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        if (exposureLogging !== ExposureLogging.Disabled) {
                            this.logGateExposureImpl(user, gateName, evaluation, ExposureCause.Automatic);
                        }
                        return [2 /*return*/, Promise.resolve({ value: evaluation.value })];
                }
            });
        });
    };
    StatsigServer.prototype.logConfigExposureImpl = function (user, configName, evaluation, exposureCause) {
        this._logger.logConfigExposure(user, configName, evaluation, exposureCause === ExposureCause.Manual);
    };
    StatsigServer.prototype.getConfigImpl = function (inputUser, configName, exposureLogging) {
        var _a = this._validateInputs(inputUser, configName), rejection = _a.rejection, user = _a.normalizedUser;
        if (rejection) {
            return rejection;
        }
        var evaluation = this._evaluator.getConfig(user, configName);
        if (evaluation.fetch_from_server) {
            return this._fetchConfig(user, configName, exposureLogging);
        }
        var config = new DynamicConfig_1["default"](configName, evaluation.json_value, evaluation.rule_id, evaluation.secondary_exposures);
        if (exposureLogging !== ExposureLogging.Disabled) {
            this.logConfigExposureImpl(user, configName, evaluation, ExposureCause.Automatic);
        }
        return Promise.resolve(config);
    };
    StatsigServer.prototype.getLayerImpl = function (inputUser, layerName, exposureLogging) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, rejection, user, ret, logFunc, layer, config, _b;
            var _this = this;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _a = this._validateInputs(inputUser, layerName), rejection = _a.rejection, user = _a.normalizedUser;
                        if (rejection) {
                            return [2 /*return*/, rejection];
                        }
                        ret = this._evaluator.getLayer(user, layerName);
                        if (!ret.fetch_from_server) {
                            logFunc = function (layer, parameterName) {
                                _this.logLayerParameterExposureImpl(user, layerName, parameterName, ret, ExposureCause.Automatic);
                            };
                            layer = new Layer_1["default"](layerName, ret === null || ret === void 0 ? void 0 : ret.json_value, ret === null || ret === void 0 ? void 0 : ret.rule_id, exposureLogging === ExposureLogging.Disabled ? null : logFunc);
                            return [2 /*return*/, Promise.resolve(layer)];
                        }
                        if (!ret.config_delegate) return [3 /*break*/, 6];
                        _c.label = 1;
                    case 1:
                        _c.trys.push([1, 4, , 6]);
                        return [4 /*yield*/, this._fetchConfig(user, ret.config_delegate, exposureLogging)];
                    case 2:
                        config = _c.sent();
                        return [4 /*yield*/, Promise.resolve(new Layer_1["default"](layerName, config === null || config === void 0 ? void 0 : config.value, config === null || config === void 0 ? void 0 : config.getRuleID()))];
                    case 3: return [2 /*return*/, _c.sent()];
                    case 4:
                        _b = _c.sent();
                        return [4 /*yield*/, Promise.resolve(new Layer_1["default"](layerName))];
                    case 5: return [2 /*return*/, _c.sent()];
                    case 6: return [2 /*return*/, Promise.resolve(new Layer_1["default"](layerName))];
                }
            });
        });
    };
    StatsigServer.prototype.logLayerParameterExposureImpl = function (user, layerName, parameterName, evaluation, exposureCause) {
        if (this._logger == null) {
            return;
        }
        this._logger.logLayerExposure(user, layerName, parameterName, evaluation, exposureCause === ExposureCause.Manual);
    };
    StatsigServer.prototype._validateInputs = function (user, configName) {
        var result = { rejection: null, normalizedUser: {} };
        if (this._ready !== true) {
            result.rejection = Promise.reject(new Errors_1.StatsigUninitializedError());
        }
        else if (typeof configName !== 'string' || configName.length === 0) {
            result.rejection = Promise.reject(new Errors_1.StatsigInvalidArgumentError('Lookup key must be a non-empty string'));
        }
        else if (!(0, core_1.isUserIdentifiable)(user)) {
            result.rejection = Promise.reject(new Errors_1.StatsigInvalidArgumentError('Must pass a valid user with a userID or customID for the server SDK to work. See https://docs.statsig.com/messages/serverRequiredUserID/ for more details.'));
        }
        else {
            result.normalizedUser = normalizeUser(user, this._options);
        }
        var resetError = this._evaluator.resetSyncTimerIfExited();
        if (resetError != null) {
            this._errorBoundary.logError(resetError, 'reset_sync_time');
        }
        return result;
    };
    StatsigServer.prototype._fetchConfig = function (user, name, exposureLogging) {
        return this._fetcher
            .dispatch(this._options.api + '/get_config', {
            user: user,
            configName: name,
            statsigMetadata: (0, core_1.getStatsigMetadata)({
                exposureLoggingDisabled: exposureLogging === ExposureLogging.Disabled
            })
        }, 5000)
            .then(function (res) {
            // @ts-ignore
            return res.json();
        })
            .then(function (resJSON) {
            return Promise.resolve(new DynamicConfig_1["default"](name, resJSON.value, resJSON.rule_id));
        })["catch"](function () {
            return Promise.resolve(new DynamicConfig_1["default"](name));
        });
    };
    return StatsigServer;
}());
exports["default"] = StatsigServer;
function shouldTrimParam(param, size) {
    if (param == null)
        return false;
    if (typeof param === 'string')
        return param.length > size;
    if (typeof param === 'object') {
        return JSON.stringify(param).length > size;
    }
    if (typeof param === 'number')
        return param.toString().length > size;
    return false;
}
function normalizeUser(user, options) {
    user = trimUserObjIfNeeded(user);
    user = JSON.parse(JSON.stringify(user));
    if ((options === null || options === void 0 ? void 0 : options.environment) != null) {
        user['statsigEnvironment'] = options === null || options === void 0 ? void 0 : options.environment;
    }
    return user;
}
function trimUserObjIfNeeded(user) {
    if (user == null)
        return {};
    if (user.userID != null && shouldTrimParam(user.userID, MAX_VALUE_SIZE)) {
        console.warn('statsigSDK> User ID is too large, trimming to ' + MAX_VALUE_SIZE);
        user.userID = user.userID.toString().substring(0, MAX_VALUE_SIZE);
    }
    if (shouldTrimParam(user, MAX_USER_SIZE)) {
        user.custom = { statsig_error: 'User object length too large' };
        if (shouldTrimParam(user, MAX_USER_SIZE)) {
            console.warn('statsigSDK> User object is too large, only keeping the user ID.');
            user = { userID: user.userID };
        }
        else {
            console.warn('statsigSDK> User object is too large, dropping the custom property.');
        }
    }
    return user;
}
